import fs from 'node:fs/promises';
import path from 'node:path';

/**
 * XTIR Archive index generator
 *
 * Scans:   public/xtir-archive/
 * Outputs: src/data/archive.generated.ts
 */

const PROJECT_ROOT = process.cwd();
const ARCHIVE_DIR = path.join(PROJECT_ROOT, 'public', 'xtir-archive');
const OUT_FILE = path.join(PROJECT_ROOT, 'src', 'data', 'archive.generated.ts');

const toPosix = (p) => p.split(path.sep).join('/');

const typeByExt = (ext) => {
  const e = ext.toLowerCase();
  if (['.pdf'].includes(e)) return 'pdf';
  if (['.mp4', '.webm', '.mov', '.m4v'].includes(e)) return 'video';
  if (['.mp3', '.wav', '.ogg', '.m4a'].includes(e)) return 'audio';
  if (['.png', '.jpg', '.jpeg', '.webp', '.gif', '.svg'].includes(e)) return 'image';
  return 'other';
};

const humanize = (name) => {
  const base = name
    .replace(/\.[^.]+$/, '')
    .replace(/[_]+/g, ' ')
    .replace(/[-]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  if (!base) return name;
  return base.charAt(0).toUpperCase() + base.slice(1);
};

async function walk(dir) {
  /** @type {Array<{ abs: string, rel: string, stat: import('node:fs').Stats }>} */
  const files = [];

  async function recur(current) {
    let entries = [];
    try {
      entries = await fs.readdir(current, { withFileTypes: true });
    } catch (e) {
      // If archive folder doesn't exist yet, that's fine.
      return;
    }

    for (const ent of entries) {
      if (ent.name.startsWith('.')) continue;
      const abs = path.join(current, ent.name);
      if (ent.isDirectory()) {
        await recur(abs);
        continue;
      }
      if (!ent.isFile()) continue;
      const stat = await fs.stat(abs);
      const rel = path.relative(dir, abs);
      files.push({ abs, rel, stat });
    }
  }

  await recur(dir);
  return files;
}

function tsString(v) {
  return JSON.stringify(v);
}

async function main() {
  const list = await walk(ARCHIVE_DIR);

  const items = list
    .map(({ rel, stat }) => {
      const relPosix = toPosix(rel);
      const ext = path.extname(relPosix);
      const folder = relPosix.includes('/') ? relPosix.split('/').slice(0, -1).join('/') : '';
      const url = `/xtir-archive/${relPosix}`;
      return {
        id: relPosix, // stable id == relative path
        title: humanize(path.basename(relPosix)),
        relPath: relPosix,
        folder,
        url,
        type: typeByExt(ext),
        size: stat.size,
        updatedAt: new Date(stat.mtimeMs).toISOString(),
      };
    })
    .sort((a, b) => (a.folder + a.title).localeCompare(b.folder + b.title, 'ru'));

  const content = `/* eslint-disable */
/* AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
   Generated by: scripts/build-archive-index.mjs */

export type ArchiveItemType = 'pdf' | 'video' | 'audio' | 'image' | 'other';

export interface ArchiveItem {
  id: string;
  title: string;
  relPath: string;
  folder: string;
  url: string;
  type: ArchiveItemType;
  size: number;
  updatedAt: string;
}

export const ARCHIVE_ASSET_BASE = '/xtir-archive';

export const archiveItems: ArchiveItem[] = [
${items
  .map((it) =>
    `  { id: ${tsString(it.id)}, title: ${tsString(it.title)}, relPath: ${tsString(it.relPath)}, folder: ${tsString(
      it.folder,
    )}, url: ${tsString(it.url)}, type: ${tsString(it.type)}, size: ${it.size}, updatedAt: ${tsString(it.updatedAt)} },`,
  )
  .join('\n')}
];
`;

  await fs.mkdir(path.dirname(OUT_FILE), { recursive: true });
  await fs.writeFile(OUT_FILE, content, 'utf8');

  // eslint-disable-next-line no-console
  console.log(`Archive index generated: ${path.relative(PROJECT_ROOT, OUT_FILE)} (items: ${items.length})`);
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exit(1);
});
